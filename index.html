<!doctype html>
<html>
<head>
  <script defer src="https://cdn.jsdelivr.net/npm/xlsx@0.20.3/dist/xlsx.full.min.js"></script>
  <meta charset="utf-8"/>
  <title>Miners Excel Viewer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    button, select { padding: 8px 12px; }
    table { border-collapse: collapse; width: 100%; margin-top: 12px; }
    th, td { border: 1px solid #ddd; padding: 6px; font-size: 12px; }
    th { background: #f5f5f5; position: sticky; top: 0; }
    #status { margin-left: 10px; }
    .muted { color: #666; font-size: 12px; }
  </style>


</head>

<body>
  <h2>Excel Viewer</h2>

  <div class="row">
    <label for="sheetSelect"><b>Sheet:</b></label>
    <select id="sheetSelect"></select>

    <button id="reloadBtn">Reload data</button>

    <button id="refreshBtn" title="Trigger refresh on your PC (optional)">Trigger Excel refresh</button>
    <span id="status" class="muted"></span>
  </div>

  <div style="margin-top:10px;">
    <b>Last updated:</b> <span id="lastUpdated">-</span>
    <span id="meta" class="muted"></span>
  </div>

  <table id="tbl"></table>

<script>
  // Optional: set to your tunnel endpoint, e.g. https://refresh.example.com/refresh
  const REFRESH_API_URL = "";

  const INDEX_URL = "data/index.json";

  function setStatus(msg) {
    document.getElementById("status").innerText = msg || "";
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderTable(rows) {
    const tbl = document.getElementById("tbl");
    tbl.innerHTML = "";

    if (!rows || rows.length === 0) return;

    const thead = document.createElement("thead");
    const hr = document.createElement("tr");
    (rows[0] || []).forEach(h => {
      const th = document.createElement("th");
      th.innerHTML = escapeHtml(h);
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    tbl.appendChild(thead);

    const tbody = document.createElement("tbody");
    rows.slice(1).forEach(r => {
      const tr = document.createElement("tr");
      (r || []).forEach(c => {
        const td = document.createElement("td");
        td.innerHTML = escapeHtml(c);
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    tbl.appendChild(tbody);
  }

  async function fetchJson(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`Failed to load ${url} (${r.status})`);
    return await r.json();
  }

  async function fetchText(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`Failed to load ${url} (${r.status})`);
    return await r.text();
  }

  async function fetchArrayBuffer(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`Failed to load ${url} (${r.status})`);
    return await r.arrayBuffer();
  }

  function parseCSV(text) {
    // Simple CSV parser (no quoted commas). Keep for backward compatibility.
    const lines = text.trim().split(/\r?\n/);
    return lines.map(line => line.split(","));
  }

  async function parseXLSX(url) {
    const ab = await fetchArrayBuffer(url);
    const wb = XLSX.read(ab, { type: "array" });

    // Each exported file is a single-sheet workbook, but we handle multi-sheet anyway.
    const sheetName = wb.SheetNames[0];
    const ws = wb.Sheets[sheetName];

    // Convert to 2D array; raw:false makes it render formatted text (dates, % etc.) more nicely
    const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: false });

    // Normalize: ensure every row has same column count (so table doesn't misalign)
    const maxCols = rows.reduce((m, r) => Math.max(m, (r || []).length), 0);
    const normalized = rows.map(r => {
      const row = (r || []).map(v => v == null ? "" : String(v));
      while (row.length < maxCols) row.push("");
      return row;
    });

    return normalized;
  }

  async function loadIndexAndPopulateSheets() {
    setStatus("Loading index...");
    const index = await fetchJson(INDEX_URL);

    document.getElementById("lastUpdated").innerText = index.last_updated || "-";
    const meta = [];
    if (typeof index.sheet_count === "number") meta.push(`${index.sheet_count} sheets`);
    if (index.workbook) meta.push(`source: ${index.workbook}`);
    document.getElementById("meta").innerText = meta.length ? `(${meta.join(" Â· ")})` : "";

    const sheets = index.sheets || [];
    const select = document.getElementById("sheetSelect");
    select.innerHTML = "";

    if (!sheets.length) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(No sheets found)";
      select.appendChild(opt);
      setStatus("No sheets exported.");
      return { index, sheets };
    }

    // Populate dropdown
    for (const s of sheets) {
      const opt = document.createElement("option");
      opt.value = s.file; // e.g. sheets/Golds.xlsx  (or legacy sheets/Golds.csv)
      const labelParts = [s.sheet];
      if (typeof s.rows === "number" && typeof s.cols === "number") {
        labelParts.push(`(${s.rows}x${s.cols})`);
      }
      opt.textContent = labelParts.join(" ");
      select.appendChild(opt);
    }

    setStatus("");
    return { index, sheets };
  }

  async function loadSelectedSheet() {
    const select = document.getElementById("sheetSelect");
    const file = select.value; // e.g. sheets/Golds.xlsx
    if (!file) return;

    setStatus("Loading sheet...");

    const url = "data/" + file;

    let rows;
    if (file.toLowerCase().endsWith(".xlsx") || file.toLowerCase().endsWith(".xls")) {
      rows = await parseXLSX(url);
    } else {
      // legacy CSV path
      const csvText = await fetchText(url);
      rows = parseCSV(csvText);
    }

    renderTable(rows);
    setStatus("Loaded.");
  }

  async function reloadAll() {
    try {
      const { sheets } = await loadIndexAndPopulateSheets();
      if (sheets && sheets.length) {
        await loadSelectedSheet();
      }
    } catch (e) {
      setStatus("Error: " + (e.message || e));
    }
  }

  async function triggerRefresh() {
    if (!REFRESH_API_URL) return;
    setStatus("Triggering refresh...");
    try {
      const r = await fetch(REFRESH_API_URL, { method: "POST" });
      if (!r.ok) throw new Error("Refresh failed: " + r.status);
      setStatus("Refresh triggered. Waiting then reloading...");

      setTimeout(async () => {
        await reloadAll();
      }, 8000);
    } catch (e) {
      setStatus("Error: " + (e.message || e));
    }
  }

  document.getElementById("sheetSelect").addEventListener("change", loadSelectedSheet);
  document.getElementById("reloadBtn").addEventListener("click", reloadAll);

  const refreshBtn = document.getElementById("refreshBtn");
  if (!REFRESH_API_URL) {
    refreshBtn.style.display = "none";
  } else {
    refreshBtn.addEventListener("click", triggerRefresh);
  }

  reloadAll();
</script>
</body>
</html>
